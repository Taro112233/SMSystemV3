// scripts/merge-seeds.js - InvenStock Multi-Tenant Seed Merger V2.0
// ‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏ß‡∏° seed files ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multi-Tenant Inventory Management

const fs = require("fs");
const path = require("path");

const SEEDS_DIR = path.join(__dirname, "../prisma/seeds");
const OUTPUT_FILE = path.join(__dirname, "../prisma/seed.ts");

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£ seed ‡∏ï‡∏≤‡∏° dependencies
const SEED_ORDER = {
  "users.seed.ts": 1,           // ‡∏™‡∏£‡πâ‡∏≤‡∏á users ‡∏Å‡πà‡∏≠‡∏ô
  "organizations.seed.ts": 2,   // ‡∏™‡∏£‡πâ‡∏≤‡∏á organizations ‡πÅ‡∏•‡∏∞ departments
  "demo-data.seed.ts": 3,       // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
};

function extractExportedFunction(content, filename) {
  // Remove imports and exports to get clean function content
  const lines = content.split('\n');
  let functionContent = '';
  let insideFunction = false;
  let braceCount = 0;
  let functionName = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Find exported function
    const functionMatch = line.match(/export async function (\w+)\(/);
    if (functionMatch) {
      functionName = functionMatch[1];
      insideFunction = true;
      functionContent += line + '\n';
      braceCount += (line.match(/\{/g) || []).length;
      continue;
    }

    if (insideFunction) {
      functionContent += line + '\n';
      braceCount += (line.match(/\{/g) || []).length;
      braceCount -= (line.match(/\}/g) || []).length;
      
      if (braceCount === 0) {
        break;
      }
    }
  }

  if (!functionName) {
    console.warn(`‚ö†Ô∏è  No exported function found in ${filename}`);
    return null;
  }

  return {
    name: functionName,
    sourceFile: filename,
    content: functionContent.replace('export ', ''), // Remove export keyword
  };
}

function mergeSeeds() {
  console.log("üå± InvenStock Multi-Tenant Seed Merger V2.0");
  console.log("üè¢ Multi-Organization Inventory Management System");
  
  if (!fs.existsSync(SEEDS_DIR)) {
    console.error(`‚ùå Seeds directory not found: ${SEEDS_DIR}`);
    process.exit(1);
  }

  const seedFiles = fs
    .readdirSync(SEEDS_DIR)
    .filter((file) => file.endsWith(".seed.ts"))
    .filter((file) => SEED_ORDER[file])
    .sort((a, b) => {
      const orderA = SEED_ORDER[a] ?? 999;
      const orderB = SEED_ORDER[b] ?? 999;
      return orderA - orderB;
    });

  if (seedFiles.length === 0) {
    console.error("‚ùå No seed files found");
    process.exit(1);
  }

  console.log(`üìÅ Found ${seedFiles.length} seed files`);

  const extractedFunctions = [];
  const imports = [];

  for (const file of seedFiles) {
    const filePath = path.join(SEEDS_DIR, file);
    const content = fs.readFileSync(filePath, "utf8");

    const extracted = extractExportedFunction(content, file);
    if (extracted) {
      extractedFunctions.push(extracted);

      const moduleBaseName = file.replace(".seed.ts", "");
      imports.push(
        `import { ${extracted.name} } from "./seeds/${moduleBaseName}.seed";`
      );
    }
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö functions ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
  const hasUsersFunction = extractedFunctions.some(
    (f) => f.name === "seedUsers"
  );
  const hasOrganizationsFunction = extractedFunctions.some(
    (f) => f.name === "seedOrganizations"
  );
  const hasDemoDataFunction = extractedFunctions.some(
    (f) => f.name === "seedDemoData"
  );

  // Generate merged seed file
  const mergedContent = generateInvenStockSeed(extractedFunctions, imports, {
    hasUsersFunction,
    hasOrganizationsFunction,
    hasDemoDataFunction,
  });

  // Write merged file
  try {
    fs.writeFileSync(OUTPUT_FILE, mergedContent, "utf8");
    console.log(`‚úÖ Generated: ${OUTPUT_FILE}`);
    console.log(`üìä Functions: ${extractedFunctions.length}`);
    console.log(`üöÄ Ready to run: npm run db:setup`);
  } catch (error) {
    console.error("‚ùå Failed to write merged seed:", error.message);
    process.exit(1);
  }
}

function generateInvenStockSeed(functions, imports, seedFlags) {
  const {
    hasUsersFunction,
    hasOrganizationsFunction,
    hasDemoDataFunction,
  } = seedFlags;

  return `// prisma/seed.ts - InvenStock Multi-Tenant System V2.0
// Generated by scripts/merge-seeds.js
// Do not edit manually - modify individual seed files instead

import { PrismaClient } from "@prisma/client";
import { hashPassword } from "../lib/auth";
import { generateInviteCode } from "../lib/invite-code";

${imports.join("\n")}

const prisma = new PrismaClient();

async function main() {
  console.log("üå± Starting InvenStock Multi-Tenant Seed...");
  
  try {
    // Clear existing data in development
    if (process.env.NODE_ENV === 'development') {
      console.log("üßπ Clearing existing data...");
      await clearExistingData();
    }

    // USER MANAGEMENT
    console.log("üë• Creating users...");
    
    ${
      hasUsersFunction
        ? `
    const userResult = await seedUsers(prisma);
    console.log(\`‚úÖ Users: \${userResult.totalUsers}\`);
    const adminUser = userResult.adminUser;
    `
        : `
    console.log("üë• Creating basic users...");
    const hashedPassword = await hashPassword("admin123");
    
    // Create system admin user
    const adminUser = await prisma.user.upsert({
      where: { username: "admin" },
      update: {
        password: hashedPassword, // Update password if exists
      },
      create: {
        username: "admin",
        password: hashedPassword,
        firstName: "‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•",
        lastName: "‡∏£‡∏∞‡∏ö‡∏ö",
        email: "admin@inventock.com",
        phone: "0800000000",
        status: "ACTIVE",
        isActive: true,
        emailVerified: true,
      },
    });
    
    console.log("‚úÖ Users: admin/admin123");
    `
    }

    // ORGANIZATION MANAGEMENT
    console.log("üè¢ Creating organizations...");
    
    ${
      hasOrganizationsFunction
        ? `
    const orgResult = await seedOrganizations(prisma);
    console.log(\`‚úÖ Organizations: \${orgResult.totalOrganizations}, Departments: \${orgResult.totalDepartments}\`);
    `
        : `
    console.log("üè¢ Creating basic organization...");
    
    // Get admin user (should be available from previous step)
    const currentAdmin = adminUser || await prisma.user.findUnique({
      where: { username: "admin" }
    });
    
    if (!currentAdmin) {
      throw new Error("Admin user not found");
    }

    // Create demo organization
    const demoOrganization = await prisma.organization.upsert({
      where: { slug: "demo-organization" },
      update: {},
      create: {
        name: "‡∏≠‡∏á‡∏Ñ‡πå‡∏Å‡∏£‡πÄ‡∏î‡πÇ‡∏°",
        slug: "demo-organization",
        description: "‡∏≠‡∏á‡∏Ñ‡πå‡∏Å‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö InvenStock",
        email: "demo@inventock.com",
        phone: "0800000001",
        status: "ACTIVE",
        timezone: "Asia/Bangkok",
        inviteCode: generateInviteCode(),
        inviteEnabled: true,
      },
    });

    // Make admin the owner
    await prisma.organizationUser.upsert({
      where: {
        organizationId_userId: {
          organizationId: demoOrganization.id,
          userId: currentAdmin.id,
        }
      },
      update: {},
      create: {
        organizationId: demoOrganization.id,
        userId: currentAdmin.id,
        roles: "OWNER",
        isOwner: true,
        isActive: true,
      },
    });

    // Create basic departments
    await prisma.department.createMany({
      data: [
        {
          organizationId: demoOrganization.id,
          name: "‡πÅ‡∏ú‡∏ô‡∏Å‡∏´‡∏•‡∏±‡∏Å",
          code: "MAIN",
          description: "‡πÅ‡∏ú‡∏ô‡∏Å‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö",
          color: "BLUE",
          icon: "BUILDING",
          isActive: true,
          createdBy: currentAdmin.id,
        },
        {
          organizationId: demoOrganization.id,
          name: "‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤",
          code: "WAREHOUSE",
          description: "‡∏Ñ‡∏•‡∏±‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤",
          color: "GREEN",
          icon: "WAREHOUSE",
          isActive: true,
          createdBy: currentAdmin.id,
        },
      ],
      skipDuplicates: true,
    });

    console.log("‚úÖ Organizations: 1, Departments: 2");
    `
    }

    // DEMO DATA (always enabled for production readiness)
    console.log("üé≠ Creating complete dataset...");
    
    ${
      hasDemoDataFunction
        ? `
    const demoResult = await seedDemoData(prisma);
    console.log(\`‚úÖ \${demoResult.message}\`);
    `
        : `
    // Create additional users for full system
    await createCompleteUserSet(prisma);
    console.log("‚úÖ Complete user set created");
    `
    }

    // VERIFICATION
    console.log("üîç Verifying system...");
    const verification = await verifySystem(prisma);
    
    console.log("="+"=".repeat(50));
    console.log("üéâ InvenStock Multi-Tenant System Ready!");
    console.log(\`üë• Users: \${verification.users}\`);
    console.log(\`üè¢ Organizations: \${verification.organizations}\`);
    console.log(\`üè¨ Departments: \${verification.departments}\`);
    console.log(\`üìã Org Memberships: \${verification.orgUsers}\`);
    console.log(\`üìä Audit Logs: \${verification.auditLogs}\`);
    console.log("="+"=".repeat(50));
    console.log("üöÄ Next: npm run dev");
    console.log("üîë Admin Login: admin / admin123");

  } catch (error) {
    console.error("üí• Seed error:", error.message);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

async function clearExistingData() {
  try {
    // Clear in reverse dependency order
    await prisma.auditLog.deleteMany({});
    await prisma.department.deleteMany({});
    await prisma.organizationUser.deleteMany({});
    await prisma.organization.deleteMany({});
    await prisma.user.deleteMany({});
    
    console.log("‚úÖ Existing data cleared");
  } catch (error) {
    console.warn("‚ö†Ô∏è  Could not clear data:", error.message);
  }
}

async function createCompleteUserSet(prisma: PrismaClient) {
  try {
    const hashedPassword = await hashPassword("demo123");
    
    // Additional users for production readiness
    await prisma.user.createMany({
      data: [
        {
          username: "manager.hospital",
          password: hashedPassword,
          firstName: "‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£",
          lastName: "‡πÇ‡∏£‡∏á‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•",
          email: "manager@hospital.com",
          status: "ACTIVE",
          isActive: true,
        },
        {
          username: "staff.pharmacy",
          password: hashedPassword,
          firstName: "‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô",
          lastName: "‡∏£‡πâ‡∏≤‡∏ô‡∏¢‡∏≤",
          email: "staff@pharmacy.com", 
          status: "ACTIVE",
          isActive: true,
        },
      ],
      skipDuplicates: true,
    });
  } catch (error) {
    console.warn("‚ö†Ô∏è  Could not create additional users:", error.message);
  }
}

async function verifySystem(prisma: PrismaClient) {
  try {
    const [users, organizations, departments, orgUsers, auditLogs] = await Promise.all([
      prisma.user.count(),
      prisma.organization.count(),
      prisma.department.count(),
      prisma.organizationUser.count(),
      prisma.auditLog.count(),
    ]);

    return { users, organizations, departments, orgUsers, auditLogs };
  } catch (error) {
    console.error("‚ùå Verification failed:", error.message);
    return { users: 0, organizations: 0, departments: 0, orgUsers: 0, auditLogs: 0 };
  }
}

main()
  .catch((e) => {
    console.error("üí• FATAL ERROR:");
    console.error(e.message);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

export { prisma };`
}

// Execute if run directly
if (require.main === module) {
  mergeSeeds();
}

module.exports = { mergeSeeds };